# Завдання 4.1
Перш за все я дізналась розмір size_t у FreeBSD написавши код. Скомпілювала його і отримала результат: 

Size_t size:8 bytes

Після цього пишу код який буде намагатись виділити велику кількість.

Attempting to allocate 18446744073709551615 bytes 

malloc failed: Cannot allocate memory

А що стосується питання чому теоретично максимальний обсяг складає 8 ексабайт, а не 16, то на 64-бітних системах size_t займає 8 байтів. До того ж теоретично максимальне значення size_t – 2^64-1(18.4 EБ). Тому практично malloc(3) не може видітили більше 8 ЕБ.

Перевірка:

Sysctl hw.physmem

# Завдання 4.2

Що станеться, якщо передати malloc(3) від’ємний аргумент? 

Функція malloc(3) приймає параметр типу size_t, який є беззнаковим (unsigned). Якщо передати від’ємне значення, воно буде неявно перетворене в size_t, що призведе до дуже великого числа. Це призведе до помилки.
Далі написала тестовий випадок, який обчислює кількість виділених байтів за формулою num = xa * xb. Завдяки цьому коду ми перевіримо, що станеться, якщо перемножити два знаковий значення та отримати від’ємний результат, який буде передано у malloc(3).

Після компіляції отримуємо: 

Multiplication result: -727379968

malloc failed: Cannot allocate memory

Що буде, якщо num оголошене як цілочисельна змінна зі знаком, а результат множення призведе до переповнення?

Якщо num має тип int або long і результат множення двох великих чисел перевищує максимальне значення, то відбувається переповнення знакового типу

Як себе поведе malloc(3)? 

malloc(3) приймає аргумент типу size_t, який є беззнаковим. Виходячи з цього від’ємне значення сприймається як дуже велике позитивне число. Відповідно виникне помилка виділення пам’яті. 

# Завдання 4.3

Що станеться, якщо передати malloc(3) від’ємний аргумент? 

Функція malloc(3) приймає параметр типу size_t, який є беззнаковим (unsigned). Якщо передати від’ємне значення, воно буде неявно перетворене в size_t, що призведе до дуже великого числа. Це призведе до помилки.
Далі написала тестовий випадок, який обчислює кількість виділених байтів за формулою num = xa malloc(0) може поводитися по-різному залежно від реалізації malloc(3) у FreeBSD. Або ж malloc(0) повертає NULL, що означає, що виділення пам’яті не відбулося. Або ж повертає непорожній (не NULL) вказівник, який можна безпечно передати у free(). 
Пишу тестовий випадок у якому malloc(0) повертає NULL або вказівник, що не є NULL, і який можна передати у free().

Компілюємо:

malloc(0) returned a valid pointer: 0x1b0ae1808008 

Pointer freed successfully.

І далі запускаємо через Itrace. Спочатку захожу в рут права і встановлюю Itrace:

Sudo pkg install Itrace

Запускаємо і у результаті бачимо, що програма викликала malloc(0), і функція malloc() повернула вказівник 0x3e3ad4800808 замість NULL. Це означає, що навіть для malloc(0) система виділила певний керований службовий блок пам’яті.

# Завдання 4.4 

Помилка в коді полягає в тому, що ptr звільняється у free(ptr) в кінці циклу. Але вже в наступній ітерації умова if (!prt) не спрацьовує, бо prt вже отримав значення, при тому що воно недійсне після free(ptr). 
Пишемо програму яка продемонструє помилку, ми виділяємо пам'ять один раз всередині циклу, але після звільнення пам'яті намагаємося знову використовувати той самий вказівник без перевизначення. Кожен виклик free(ptr) викликає звільнення пам'яті. Якщо цикл виконується кілька разів, пам'ять буде звільнена кілька разів. І отримаємо помилку:

Iteration 1, ptr = 0x26e417213000

Iteration 2, ptr = 0x26e417213000

Далі пишемо правильний код. Ми виділяє пам’ять один раз в циклі. Пам’ять звільняється лише після завершення циклу. Якщо пам’ять не вдалося виділити за допомогою malloc, програма виведе повідомлення про помилку.

#include <stdio.h>

#include <stdlib.h>

int main() {

    void *ptr = NULL;
    
    for (int i = 0; i < 2; ++i) {
    
        if (!ptr) {
        
            ptr = malloc(10); 
            
            if (!ptr) {
            
                perror("malloc failed");
                
                return 1; 
                
            }
            
            printf("Memory allocated\n");
            
        }
        
        if (ptr) {
        
            printf("Using ptr in iteration %d\n", i + 1);
            
        }
        
        if (i == 1) {
        
            free(ptr);
            
            printf("Memory freed\n");
            
        }
        
    }
    
    return 0;
    
}


Результат:

Memory allocated

Using ptr in iteration 1

Using ptr in iteration 2

Memory freed

"Memory allocated": це повідомлення виводиться тільки в першій ітерації циклу, коли пам'ять виділяється через malloc.

"Using ptr in iteration X": це повідомлення виводиться в обох ітераціях, оскільки пам'ять була виділена, і вказівник ptr не є NULL.

"Memory freed": це повідомлення виводиться тільки в останній ітерації (коли i == 1), коли виконується звільнення пам'яті через free(ptr).

# Завдання 4.5

Якщо realloc() не зможе виділити новий блок пам’яті, він поверне NULL, а початковий вказівник залишиться без змін. Далі пишу тестовий випадок в якому викличу realloc() із дуже великим розміром пам’яті, щоб змусити його повернути NULL. 

#include <stdio.h>

#include <stdlib.h>

int main() {

    size_t huge_size = (size_t)-1; 
    
    void *ptr = malloc(1024);
    
    if (!ptr) {
    
        perror("Initial malloc failed");
        
        return 1;
        
    }
    
    printf("Memory allocated at: %p\n", ptr);
    
    void *new_ptr = realloc(ptr, huge_size);
    
    if (!new_ptr) {
    
        perror("realloc failed");  
        
        free(ptr); 
        
        return 1;
        
    }
    
    printf("Reallocation successful at: %p\n", new_ptr);
    
    free(new_ptr);
    
    return 0;
    
}

Результат:

Memory allocated at: 0x29248b609000

realloc failed: Cannot allocate memory

Це означає, що початкова malloc(1024) успішно виділила пам’ять. Виводиться адреса виділеної області. А realloc(ptr, huge_size) не зміг виділити пам’ять, тому повернув NULL. perror("realloc failed") друкує "Cannot allocate memory", це стандартне повідомлення системи, коли пам’яті недостатньо.

# Завдання 4.6

Якщо передати у realloc() вказівник NULL, функція просто працюватиме як malloc() і виділить нову область пам’яті потрібного розміру. Якщо ж передати 0 як розмір, просто звільнитися пам’ять (free(ptr)) і повернеться NULL. Пишу тестовий варіант

#include <stdio.h>

#include <stdlib.h>

int main() {

    void *ptr = NULL;
    
    ptr = realloc(NULL, 100);
    
    if (ptr) {
    
        printf("realloc(NULL, 100) успішно, ptr = %p\n", ptr);
        
    } else {
    
        printf("realloc(NULL, 100) повернув NULL\n");
        
    }
    
    void *new_ptr = realloc(ptr, 0);
    
    if (new_ptr) {
    
        printf("realloc(ptr, 0) повернув %p\n", new_ptr);
        
    } else {
    
        printf("realloc(ptr, 0) повернув NULL (звільнено пам'ять)\n");
        
    }
    
    return 0;
    
}

і у результаті:

realloc(NULL, 100) successful, ptr = 0x3496cae09000

realloc(ptr, 0) returned 0x3496cae08008

Через специфічну поведінку jemalloc, realloc(ptr, 0) повертає не 0, а адресу, яку потім потрібно звільнити. 

# Завдання 4.7

В запропонованому коді виділяється пам’ять для 1000 структур sbar за допомогою calloc, а потім змінює розмір виділеної пам’яті на 500 структур через realloc.
Далі переписали код з reallocarray(3)

#include <stdio.h>  

#include <stdlib.h> 

struct sbar {

    int data;
    
};

int main() {

    struct sbar *ptr, *newptr;
    
    ptr = calloc(1000, sizeof(struct sbar));
    
    if (!ptr) {
    
        perror("calloc failed");
        
        return 1;
        
    }
    
    newptr = reallocarray(ptr, 500, sizeof(struct sbar));
    
    if (!newptr) {
    
        perror("reallocarray failed");
        
        free(ptr); 
        
        return 1;
        
    }
    
    free(newptr);
    
    return 0;
    
}

reallocarray(3) це — це функція , яка динамічно змінює розмір виділеної області пам’яті. 

ltrace це — це утиліта, яка відстежує виклики бібліотечних функцій, які виконує програма.

Спочатку компілюю програму за допомогою компілятора clang і запускаю через ltrace. Для того, щоб побачити виклики до функцій динамічного виділення пам'яті, таких як calloc, realloc, і free.

Результат:

libc_start1(1, 0x8205594f0, 0x820559500, 0xcedad85acc0, 0x201780 <unfinished.>

calloc(1000, 4) = 0x3efadfa09000

reallocarray (0x3ef adf a09000, 500, 4, 227, 0) = 0x3efadfa13000

free(0x3efadfa13000)  = <void>

+++ exited (status 0) +++

Пояснення виводу:

calloc: виділяється пам'ять для 1000 елементів.

reallocarray: перерозподіл пам'яті для 500 елементів.

free: звільняється пам'ять після використання.

# Завдання 4.21

Щоб перевірити роботу malloc слід обмежити доступну пам'ять для програми, а потім перевірити, як вона поводиться під час виділення пам'яті. Пишемо тестову програму, яка використовує malloc для виділення пам'яті, а потім перевіряє, чи правильно працює виділення пам'яті в умовах обмеженого ресурсу.

#include <stdio.h>

#include <stdlib.h>

int main() {

    size_t size = 100 * 1024 * 1024; 
    
    char *ptr = malloc(size);
    
    if (ptr == NULL) {
    
        perror("malloc failed");
        
        return 1;
        
    }
    
    printf("Memory allocated successfully\n");
    
    free(ptr);
    
    return 0;
    
}

Ця програма намагається виділити 100 МБ пам'яті. Якщо виділення пам'яті не вдається, вона виведе повідомлення про помилку.

Після чого обмежимо обсяг пам'яті. Для цього скористаємося ulimit.

ulimit -v <51200>

Після цього запускаємо програму, і вона повинна спробувати виділити більше пам'яті, ніж дозволено. 

dasha@host: $ ulimit -v 51200 

dasha@host:~$ clang -o PR4_21 PR4_21.c

Total segment size exceeds process limit Abort trap

./PR4_21

malloc failed: Cannot allocate memory




https://github.com/Daria123H/README_-_-4.md.git
